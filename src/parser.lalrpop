use crate::{Op, Program, Trap};
use std::str::FromStr;

grammar(prog: &mut Program);

// TODO it feels like there should be a better way to resolve ambiguities than this...
match {
    r"(?i)ADD", r"(?i)AND", r"(?i)BRn?z?p?", r"(?i)JMP", r"(?i)JSR", r"(?i)JSRR",
    r"(?i)LD",  r"(?i)LDI", r"(?i)LDR", r"(?i)LEA", r"(?i)NOT",  r"(?i)RET",
    r"(?i)RTI", r"(?i)ST",  r"(?i)STI", r"(?i)STR", r"(?i)TRAP", r"(?i)GETC",
    r"(?i)OUT", r"(?i)PUTS", r"(?i)IN", r"(?i)PUTSP", r"(?i)HALT",
    r"(?i)r[0-7]", r"(?i)x[0-9a-fA-F]{1,4}" // Reg, HexLit
} else {
    r"\s*" => { }, // The default whitespace skipping is disabled if an `ignore pattern` is specified
    r";[^\r\n]*[\r\n]" => {}, // ignore comments
    r"[a-zA-Z][_\-a-zA-Z0-9]*" => LABEL,
    _
}

pub Program: () = <orig:Origin> Statement* End => prog.orig = orig;

Origin: u16 = r"(?i)\.ORIG" <orig:HexLit> => orig;
End: () = r"(?i)\.END" => ();

Statement: () = {
    <label:Label> => {
        assert!(!prog.syms.contains_key(&label), "duplicate label: {}", label);
        prog.syms.insert(label, prog.mem.len() as u16);
    },
    <op:Op> => prog.mem.push(op),
}

Op: u16 = {
  // 3 regs, or 2 regs and an imm5
  <op:ADD> <dr:Reg> "," <sr1:Reg> "," <sr2:Reg>     => op | dr << 9 | sr1 << 6 | sr2,
  <op:ADD> <dr:Reg> "," <sr1:Reg> "," <imm5:NumLit> => op | dr << 9 | sr1 << 6 | 1 << 5 | (imm5 & 0x1f),
  <op:AND> <dr:Reg> "," <sr1:Reg> "," <sr2:Reg>     => op | dr << 9 | sr1 << 6 | sr2,
  <op:AND> <dr:Reg> "," <sr1:Reg> "," <imm5:NumLit> => op | dr << 9 | sr1 << 6 | 1 << 5 | (imm5 & 0x1f),

  // 2 registers and an offset6
  <op:LDR> <dr:Reg> "," <baser:Reg> "," <offset6:NumLit> => op | dr << 9 | baser << 6 | (offset6 & 0x3f),
  <op:STR> <dr:Reg> "," <baser:Reg> "," <offset6:NumLit> => op | dr << 9 | baser << 6 | (offset6 & 0x3f),

  // 2 registers
  <op:NOT> <dr:Reg> "," <sr:Reg> => op | dr << 9 | sr << 6,

  // 1 register and a label or a PCoffset9
  <op:LD>  <r:Reg> "," <label:Label> => { prog.refs.insert(prog.mem.len() as u16, (label.to_string(), Some(0x1ff))); op | r << 9 },
  <op:LD>  <r:Reg> "," <pcoffset9:NumLit> => op | (pcoffset9 & 0x1ff),
  <op:LDI> <r:Reg> "," <label:Label> => { prog.refs.insert(prog.mem.len() as u16, (label.to_string(), Some(0x1ff))); op | r << 9 },
  <op:LDI> <r:Reg> "," <pcoffset9:NumLit> => op | (pcoffset9 & 0x1ff),
  <op:LEA> <r:Reg> "," <label:Label> => { prog.refs.insert(prog.mem.len() as u16, (label.to_string(), Some(0x1ff))); op | r << 9 },
  <op:LEA> <r:Reg> "," <pcoffset9:NumLit> => op | (pcoffset9 & 0x1ff),
  <op:ST>  <r:Reg> "," <label:Label> => { prog.refs.insert(prog.mem.len() as u16, (label.to_string(), Some(0x1ff))); op | r << 9 },
  <op:ST>  <r:Reg> "," <pcoffset9:NumLit> => op | (pcoffset9 & 0x1ff),
  <op:STI> <r:Reg> "," <label:Label> => { prog.refs.insert(prog.mem.len() as u16, (label.to_string(), Some(0x1ff))); op | r << 9 },
  <op:STI> <r:Reg> "," <pcoffset9:NumLit> => op | (pcoffset9 & 0x1ff),

  // just 1 register
  <op:JMP>  <r:Reg> => op | r << 6,
  <op:JSRR> <r:Reg> => op | r << 6,

  // no registers, just a label or a number
  <op:BR>  <label:Label> => { prog.refs.insert(prog.mem.len() as u16, (label.to_string(), Some(0x1ff))); op },
  <op:BR>  <pcoffset9:NumLit>  => op | (pcoffset9 & 0x1ff),
  <op:JSR> <label:Label> => { prog.refs.insert(prog.mem.len() as u16, (label.to_string(), Some(0x7ff))); op },
  <op:JSR> <pcoffset11:NumLit> => op | (pcoffset11 & 0x7ff),

  // assembler directives
  r"(?i)\.FILL" <label:Label> => { prog.refs.insert(prog.mem.len() as u16, (label.to_string(), None)); 0 },
  r"(?i)\.FILL" <n:NumLit>    => n,
  r"(?i)\.STRINGZ" <s:r#""([^"])*""#> => {
    let mut chars = s[1..s.len()-1].chars();
    while let Some(c) = chars.next() {
        match c {
            '\\' => {
                if let Some(e) = chars.next() {
                    match e {
                        'a'  => prog.mem.push(0x07),
                        'b'  => prog.mem.push(0x08),
                        'e'  => prog.mem.push(0x1b),
                        'f'  => prog.mem.push(0x0c),
                        'n'  => prog.mem.push('\n' as u16),
                        'r'  => prog.mem.push('\r' as u16),
                        't'  => prog.mem.push('\t' as u16),
                        'v'  => prog.mem.push(0x0b),
                        '\\' => prog.mem.push('\\' as u16),
                        '?'  => prog.mem.push('?'  as u16),
                        '\'' => prog.mem.push('\'' as u16),
                        '"'  => prog.mem.push('"'  as u16),
                        _    => prog.mem.push(e    as u16),
                    }
                } else {
                    panic!("ran out of characters while parsing escape sequence!"); // FIXME
                }
            },
            _ => prog.mem.push(c as u16),
        }
    }
    0 // null terminate :-)
  },

  // no arguments at all
  RET   => <>,
  RTI   => <>,

  // traps
  <op:TRAP> <trapvect8:NumLit> => op | (trapvect8 & 0xff),
  GETC  => <>,
  OUT   => <>,
  PUTS  => <>,
  IN    => <>,
  PUTSP => <>,
  HALT  => <>,
}

// instructions
ADD: u16 = r"(?i)ADD" => (Op::ADD as u16) << 12;
AND: u16 = r"(?i)AND" => (Op::AND as u16) << 12;
BR:  u16 = {
    r"(?i)BRn?z?p?" => {
      let mut result = (Op::BR as u16) << 12;
        for c in <>[2..<>.len()].chars() {
            match c {
                'n' => result |= 1 << 11,
                'z' => result |= 1 << 10,
                'p' => result |= 1 << 9,
                _ => unreachable!(), // FIXME
            }
        }
        result
    }
};
JMP:  u16 = r"(?i)JMP"  => (Op::JMP as u16) << 12;
JSR:  u16 = r"(?i)JSR"  => (Op::JSR as u16) << 12 | (1 << 11);
JSRR: u16 = r"(?i)JSRR" => (Op::JSR as u16) << 12;
LD:   u16 = r"(?i)LD"   => (Op::LD as u16)  << 12;
LDI:  u16 = r"(?i)LDI"  => (Op::LDI as u16) << 12;
LDR:  u16 = r"(?i)LDR"  => (Op::LDR as u16) << 12;
LEA:  u16 = r"(?i)LEA"  => (Op::LEA as u16) << 12;
NOT:  u16 = r"(?i)NOT"  => (Op::NOT as u16) << 12 | 0x3f;
RET:  u16 = r"(?i)RET"  => (Op::JMP as u16) << 12 | (7 << 6);
RTI:  u16 = r"(?i)RTI"  => (Op::RTI as u16) << 12;
ST:   u16 = r"(?i)ST"   => (Op::ST as u16)  << 12;
STI:  u16 = r"(?i)STI"  => (Op::STI as u16) << 12;
STR:  u16 = r"(?i)STR"  => (Op::STR as u16) << 12;
    
// traps
TRAP:  u16 = r"(?i)TRAP"  => (Op::TRAP as u16) << 12 ;
GETC:  u16 = r"(?i)GETC"  => (Op::TRAP as u16) << 12 | (Trap::GETC  as u16);
OUT:   u16 = r"(?i)OUT"   => (Op::TRAP as u16) << 12 | (Trap::OUT   as u16);
PUTS:  u16 = r"(?i)PUTS"  => (Op::TRAP as u16) << 12 | (Trap::PUTS  as u16);
IN:    u16 = r"(?i)IN"    => (Op::TRAP as u16) << 12 | (Trap::IN    as u16);
PUTSP: u16 = r"(?i)PUTSP" => (Op::TRAP as u16) << 12 | (Trap::PUTSP as u16);
HALT:  u16 = r"(?i)HALT"  => (Op::TRAP as u16) << 12 | (Trap::HALT  as u16);

Label: String = LABEL => <>.to_string();

Reg: u16 = r"(?i)r[0-7]" => u16::from_str(&<>[1..<>.len()]).unwrap();

NumLit: u16 = { DecLit, HexLit };
DecLit: u16 = r"#(0|-?[1-9][0-9]*)" => i16::from_str_radix(&<>[1..<>.len()], 10).unwrap() as u16;
HexLit: u16 = r"(?i)x[0-9a-fA-F]{1,4}"   => u16::from_str_radix(&<>[1..<>.len()], 16).unwrap();
