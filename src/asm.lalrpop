use lc3::{Op, Program, Reg, Trap};
use std::str::FromStr;

grammar(prog: &mut Program);

pub Program: () = {
    r"(?i)\.ORIG" <orig:HexLit> <stmts:Statement*> r"(?i)\.END" => {
        prog.orig = orig;
        for stmt in stmts {
            // do something?
        }
    }
};

Statement: () = {
    <label:LABEL?> <op:Op> => {
        match label {
            None => (),
            Some(l) => assert_eq!(prog.sym.insert(l.to_string(), prog.len), None, "duplicate key {}", l),
        }
        println!("got op at addr {:#06x}: {:#06x}", (prog.orig+prog.len), op);
        prog.len += 1;
    }
}

Op: u16 = {
  // 3 regs, or 2 regs and an imm5
  <op:ADD> <dr:Reg> "," <sr1:Reg> "," <sr2:Reg>     => op | dr << 9 | sr1 << 6 | sr2,
  <op:ADD> <dr:Reg> "," <sr1:Reg> "," <imm5:NumLit> => op | dr << 9 | sr1 << 6 | 1 << 5 | (imm5 & 0x1f),
  <op:AND> <dr:Reg> "," <sr1:Reg> "," <sr2:Reg>     => op | dr << 9 | sr1 << 6 | sr2,
  <op:AND> <dr:Reg> "," <sr1:Reg> "," <imm5:NumLit> => op | dr << 9 | sr1 << 6 | 1 << 5 | (imm5 & 0x1f),

  // 2 registers and an offset6
  <op:LDR> <dr:Reg> "," <baser:Reg> "," <offset6:NumLit> => op | dr << 9 | baser << 6 | (offset6 & 0x3f),
  <op:STR> <dr:Reg> "," <baser:Reg> "," <offset6:NumLit> => op | dr << 9 | baser << 6 | (offset6 & 0x3f),

  // 2 registers
  <op:NOT> <dr:Reg> "," <sr:Reg> => op | dr << 9 | sr << 6,

  // 1 register and a label or a PCoffset9
  <op:LD>  <r:Reg> "," <label:LABEL> => { prog.refs.insert(label.to_string(), prog.len); op | r << 9 },
  <op:LD>  <r:Reg> "," <pcoffset9:NumLit> => op | (pcoffset9 & 0x1ff),
  <op:LDI> <r:Reg> "," <label:LABEL> => { prog.refs.insert(label.to_string(), prog.len); op | r << 9 },
  <op:LDI> <r:Reg> "," <pcoffset9:NumLit> => op | (pcoffset9 & 0x1ff),
  <op:LEA> <r:Reg> "," <label:LABEL> => { prog.refs.insert(label.to_string(), prog.len); op | r << 9 },
  <op:LEA> <r:Reg> "," <pcoffset9:NumLit> => op | (pcoffset9 & 0x1ff),
  <op:ST>  <r:Reg> "," <label:LABEL> => { prog.refs.insert(label.to_string(), prog.len); op | r << 9 },
  <op:ST>  <r:Reg> "," <pcoffset9:NumLit> => op | (pcoffset9 & 0x1ff),
  <op:STI> <r:Reg> "," <label:LABEL> => { prog.refs.insert(label.to_string(), prog.len); op | r << 9 },
  <op:STI> <r:Reg> "," <pcoffset9:NumLit> => op | (pcoffset9 & 0x1ff),

  // just 1 register
  <op:JMP> <r:Reg>  => op | r << 6,
  <op:JSRR> <r:Reg> => op | r << 6,

  // no registers, just a label or a number
  <op:BR>  <label:LABEL> => { prog.refs.insert(label.to_string(), prog.len); op },
  <op:BR>  <pcoffset9:NumLit> => op | (pcoffset9 & 0x1ff),
  <op:JSR> <label:LABEL> => { prog.refs.insert(label.to_string(), prog.len); op },
  <op:JSR> <pcoffset11:NumLit> => op | (pcoffset11 & 0x7ff),

  // no arguments at all
  RET   => <>,
  RTI   => <>,

  // traps
  <op:TRAP> <trapvect8:NumLit> => op | (trapvect8 & 0xff),
  GETC  => <>,
  OUT   => <>,
  PUTS  => <>,
  IN    => <>,
  PUTSP => <>,
  HALT  => <>,
}

// TODO it feels like there should be a better way to resolve ambiguities than this...
match {
    r"(?i)ADD", r"(?i)AND", r"(?i)BRn?z?p?", r"(?i)JMP", r"(?i)JSR",
    r"(?i)JSRR", r"(?i)LD", r"(?i)LDI", r"(?i)LDR", r"(?i)LEA", r"(?i)NOT",
    r"(?i)RET", r"(?i)RTI", r"(?i)ST",  r"(?i)STI", r"(?i)STR", r"(?i)TRAP", 
    r"(?i)GETC", r"(?i)OUT", r"(?i)PUTS", r"(?i)IN", r"(?i)PUTSP", r"(?i)HALT",
    r"(?i)r[0-7]", r"(?i)x[0-9a-fA-F]{1,4}"
} else {
    _
}

LABEL: &'input str = r"[a-zA-Z][_\-a-zA-Z0-9]*";

// instructions
ADD: u16 = r"(?i)ADD" => (Op::ADD as u16) << 12;
AND: u16 = r"(?i)AND" => (Op::AND as u16) << 12;
BR:  u16 = {
    r"(?i)BRn?z?p?" => {
      let mut result = (Op::BR as u16) << 12;
        for c in <>[2..<>.len()].chars() {
            match c {
                'n' => result |= 1 << 11,
                'z' => result |= 1 << 10,
                'p' => result |= 1 << 9,
                _ => unreachable!(), // FIXME
            }
        }
        result
    }
};
JMP:  u16 = r"(?i)JMP"  => (Op::JMP as u16) << 12;
JSR:  u16 = r"(?i)JSR"  => (Op::JSR as u16) << 12 | 1 << 11;
JSRR: u16 = r"(?i)JSRR" => (Op::JSR as u16) << 12;
LD:   u16 = r"(?i)LD"   => (Op::LD as u16)  << 12;
LDI:  u16 = r"(?i)LDI"  => (Op::LDI as u16) << 12;
LDR:  u16 = r"(?i)LDR"  => (Op::LDR as u16) << 12;
LEA:  u16 = r"(?i)LEA"  => (Op::LEA as u16) << 12;
NOT:  u16 = r"(?i)NOT"  => (Op::NOT as u16) << 12 | 0x3f;
RET:  u16 = r"(?i)RET"  => (Op::JMP as u16) << 12 | (Reg::R7 as u16) << 6;
RTI:  u16 = r"(?i)RTI"  => (Op::RTI as u16) << 12;
ST:   u16 = r"(?i)ST"   => (Op::ST as u16)  << 12;
STI:  u16 = r"(?i)STI"  => (Op::STI as u16) << 12;
STR:  u16 = r"(?i)STR"  => (Op::STR as u16) << 12;
    
// traps
TRAP:  u16 = r"(?i)TRAP"  => (Op::TRAP as u16) << 12 ;
GETC:  u16 = r"(?i)GETC"  => (Op::TRAP as u16) << 12 | (Trap::GETC  as u16);
OUT:   u16 = r"(?i)OUT"   => (Op::TRAP as u16) << 12 | (Trap::OUT   as u16);
PUTS:  u16 = r"(?i)PUTS"  => (Op::TRAP as u16) << 12 | (Trap::PUTS  as u16);
IN:    u16 = r"(?i)IN"    => (Op::TRAP as u16) << 12 | (Trap::IN    as u16);
PUTSP: u16 = r"(?i)PUTSP" => (Op::TRAP as u16) << 12 | (Trap::PUTSP as u16);
HALT:  u16 = r"(?i)HALT"  => (Op::TRAP as u16) << 12 | (Trap::HALT  as u16);

Reg: u16 = r"(?i)r[0-7]" => u16::from_str(&<>[1..<>.len()]).unwrap();

NumLit: u16 = { DecLit, HexLit };
DecLit: u16 = r"#(0|-?[1-9][0-9]*)" => u16::from_str_radix(&<>[1..<>.len()], 10).unwrap();
HexLit: u16 = r"(?i)x[0-9a-fA-F]{1,4}"   => u16::from_str_radix(&<>[1..<>.len()], 16).unwrap();
