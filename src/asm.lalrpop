use lc3::{Op, Program, Trap};
use std::str::FromStr;
use unescape::unescape;

grammar(prog: &mut Program);

// TODO it feels like there should be a better way to resolve ambiguities than this...
match {
    r"(?i)ADD", r"(?i)AND", r"(?i)BRn?z?p?", r"(?i)JMP", r"(?i)JSR", r"(?i)JSRR",
    r"(?i)LD",  r"(?i)LDI", r"(?i)LDR", r"(?i)LEA", r"(?i)NOT",  r"(?i)RET",
    r"(?i)RTI", r"(?i)ST",  r"(?i)STI", r"(?i)STR", r"(?i)TRAP", r"(?i)GETC",
    r"(?i)OUT", r"(?i)PUTS", r"(?i)IN", r"(?i)PUTSP", r"(?i)HALT",
    r"(?i)r[0-7]", r"(?i)x[0-9a-fA-F]{1,4}" // Reg, HexLit
} else {
    r"[a-zA-Z][_\-a-zA-Z0-9]*" => LABEL,
    _
}

pub Program: () = <orig:Origin> Statement* End => prog.orig = orig as usize;

Origin: u16 = r"(?i)\.ORIG" <orig:HexLit> => orig;
End: () = r"(?i)\.END" => ();

Statement: () = {
    <label:Label> => {
        assert!(!prog.syms.contains_key(&label), "duplicate label: {}", label);
        // eprintln!("setting key {} to addr {}", label, prog.mem.len());
        prog.syms.insert(label, prog.mem.len());
    },
    <op:Op> => prog.mem.push(op),
}

Op: u16 = {
  // 3 regs, or 2 regs and an imm5
  <op:ADD> <dr:Reg> "," <sr1:Reg> "," <sr2:Reg>     => op | dr << 9 | sr1 << 6 | sr2,
  <op:ADD> <dr:Reg> "," <sr1:Reg> "," <imm5:NumLit> => op | dr << 9 | sr1 << 6 | 1 << 5 | (imm5 & 0x1f),
  <op:AND> <dr:Reg> "," <sr1:Reg> "," <sr2:Reg>     => op | dr << 9 | sr1 << 6 | sr2,
  <op:AND> <dr:Reg> "," <sr1:Reg> "," <imm5:NumLit> => op | dr << 9 | sr1 << 6 | 1 << 5 | (imm5 & 0x1f),

  // 2 registers and an offset6
  <op:LDR> <dr:Reg> "," <baser:Reg> "," <offset6:NumLit> => op | dr << 9 | baser << 6 | (offset6 & 0x3f),
  <op:STR> <dr:Reg> "," <baser:Reg> "," <offset6:NumLit> => op | dr << 9 | baser << 6 | (offset6 & 0x3f),

  // 2 registers
  <op:NOT> <dr:Reg> "," <sr:Reg> => op | dr << 9 | sr << 6,

  // 1 register and a label or a PCoffset9
  <op:LD>  <r:Reg> "," <label:Label> => { prog.refs.insert(label.to_string(), prog.mem.len()); prog.mask.insert(prog.mem.len(), 0x1ff); op | r << 9 },
  <op:LD>  <r:Reg> "," <pcoffset9:NumLit> => op | (pcoffset9 & 0x1ff),
  <op:LDI> <r:Reg> "," <label:Label> => { prog.refs.insert(label.to_string(), prog.mem.len()); prog.mask.insert(prog.mem.len(), 0x1ff); op | r << 9 },
  <op:LDI> <r:Reg> "," <pcoffset9:NumLit> => op | (pcoffset9 & 0x1ff),
  <op:LEA> <r:Reg> "," <label:Label> => { prog.refs.insert(label.to_string(), prog.mem.len()); prog.mask.insert(prog.mem.len(), 0x1ff); op | r << 9 },
  <op:LEA> <r:Reg> "," <pcoffset9:NumLit> => op | (pcoffset9 & 0x1ff),
  <op:ST>  <r:Reg> "," <label:Label> => { prog.refs.insert(label.to_string(), prog.mem.len()); prog.mask.insert(prog.mem.len(), 0x1ff); op | r << 9 },
  <op:ST>  <r:Reg> "," <pcoffset9:NumLit> => op | (pcoffset9 & 0x1ff),
  <op:STI> <r:Reg> "," <label:Label> => { prog.refs.insert(label.to_string(), prog.mem.len()); prog.mask.insert(prog.mem.len(), 0x1ff); op | r << 9 },
  <op:STI> <r:Reg> "," <pcoffset9:NumLit> => op | (pcoffset9 & 0x1ff),

  // just 1 register
  <op:JMP>  <r:Reg> => op | r << 6,
  <op:JSRR> <r:Reg> => op | r << 6,

  // no registers, just a label or a number
  <op:BR>  <label:Label> => { prog.refs.insert(label.to_string(), prog.mem.len()); prog.mask.insert(prog.mem.len(), 0x1ff); op },
  <op:BR>  <pcoffset9:NumLit>  => op | (pcoffset9 & 0x1ff),
  <op:JSR> <label:Label> => { prog.refs.insert(label.to_string(), prog.mem.len()); prog.mask.insert(prog.mem.len(), 0x7ff); op },
  <op:JSR> <pcoffset11:NumLit> => op | (pcoffset11 & 0x7ff),

  // assembler directives
  r"(?i)\.FILL" <label:Label> => { prog.refs.insert(label.to_string(), prog.mem.len()); prog.mask.insert(prog.mem.len(), 0x0); 0 },
  r"(?i)\.FILL" <n:NumLit>    => n,
  r"(?i)\.STRINGZ" <s:r#""(\"|[^"])*""#> => {
    match unescape(&s[1..s.len()-1]) {
        Some(u) => {
            for c in u.chars() {
                prog.mem.push(c as u16);
            }
        },
        None => ()
    }
    0
  },

  // no arguments at all
  RET   => <>,
  RTI   => <>,

  // traps
  <op:TRAP> <trapvect8:NumLit> => op | (trapvect8 & 0xff),
  GETC  => <>,
  OUT   => <>,
  PUTS  => <>,
  IN    => <>,
  PUTSP => <>,
  HALT  => <>,
}

// instructions
ADD: u16 = r"(?i)ADD" => (Op::ADD as u16) << 12;
AND: u16 = r"(?i)AND" => (Op::AND as u16) << 12;
BR:  u16 = {
    r"(?i)BRn?z?p?" => {
      let mut result = (Op::BR as u16) << 12;
        for c in <>[2..<>.len()].chars() {
            match c {
                'n' => result |= 1 << 11,
                'z' => result |= 1 << 10,
                'p' => result |= 1 << 9,
                _ => unreachable!(), // FIXME
            }
        }
        result
    }
};
JMP:  u16 = r"(?i)JMP"  => (Op::JMP as u16) << 12;
JSR:  u16 = r"(?i)JSR"  => (Op::JSR as u16) << 12 | 1 << 11;
JSRR: u16 = r"(?i)JSRR" => (Op::JSR as u16) << 12;
LD:   u16 = r"(?i)LD"   => (Op::LD as u16)  << 12;
LDI:  u16 = r"(?i)LDI"  => (Op::LDI as u16) << 12;
LDR:  u16 = r"(?i)LDR"  => (Op::LDR as u16) << 12;
LEA:  u16 = r"(?i)LEA"  => (Op::LEA as u16) << 12;
NOT:  u16 = r"(?i)NOT"  => (Op::NOT as u16) << 12 | 0x3f;
RET:  u16 = r"(?i)RET"  => (Op::JMP as u16) << 12 | (7 << 6);
RTI:  u16 = r"(?i)RTI"  => (Op::RTI as u16) << 12;
ST:   u16 = r"(?i)ST"   => (Op::ST as u16)  << 12;
STI:  u16 = r"(?i)STI"  => (Op::STI as u16) << 12;
STR:  u16 = r"(?i)STR"  => (Op::STR as u16) << 12;
    
// traps
TRAP:  u16 = r"(?i)TRAP"  => (Op::TRAP as u16) << 12 ;
GETC:  u16 = r"(?i)GETC"  => (Op::TRAP as u16) << 12 | (Trap::GETC  as u16);
OUT:   u16 = r"(?i)OUT"   => (Op::TRAP as u16) << 12 | (Trap::OUT   as u16);
PUTS:  u16 = r"(?i)PUTS"  => (Op::TRAP as u16) << 12 | (Trap::PUTS  as u16);
IN:    u16 = r"(?i)IN"    => (Op::TRAP as u16) << 12 | (Trap::IN    as u16);
PUTSP: u16 = r"(?i)PUTSP" => (Op::TRAP as u16) << 12 | (Trap::PUTSP as u16);
HALT:  u16 = r"(?i)HALT"  => (Op::TRAP as u16) << 12 | (Trap::HALT  as u16);

Label: String = LABEL => <>.to_string();

Reg: u16 = r"(?i)r[0-7]" => u16::from_str(&<>[1..<>.len()]).unwrap();

NumLit: u16 = { DecLit, HexLit };
DecLit: u16 = r"#(0|-?[1-9][0-9]*)" => u16::from_str_radix(&<>[1..<>.len()], 10).unwrap();
HexLit: u16 = r"(?i)x[0-9a-fA-F]{1,4}"   => u16::from_str_radix(&<>[1..<>.len()], 16).unwrap();
